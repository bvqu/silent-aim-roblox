RBX::Instance silent_closestPlr{ nullptr }; RBX::Vector2 silent_lastPos{}; RBX::Vector2 silent_targetPos{}; std::thread([&]() { while (true) { if (!Settings::silentAimEnabled) { Sleep(100); continue; } RBX::Instance bestPlr{ nullptr }; RBX::Vector2 bestPos{}; float closestDistance{ Settings::silentAimFOVRadius }; silent_closestPlr = nullptr; POINT mousePos; GetCursorPos(&mousePos); RBX::Instance mouseService{ dataModel.findFirstChildOfClass("MouseService") }; RBX::Instance inputObject{ RBX::Memory::read<void*>((void*)((uintptr_t)mouseService.address + Offsets::InputObject)) }; for (RBX::Instance player : players.getChildren()) { RBX::Instance plr{ RBX::Memory::read<void*>((void*)((uintptr_t)player.address + Offsets::ModelInstance)) }; if (plr.name() == localPlayer.name()) { continue; } RBX::Instance lockPart{ plr.findFirstChild(Settings::silentAimLockPart) }; RBX::Instance torso{ plr.findFirstChild("Torso") }; if (!torso.address) // if not R6 { auto it{ std::find(aimbotLockPartsR6.begin(), aimbotLockPartsR6.end(), Settings::silentAimLockPart) }; size_t index{ static_cast<size_t>(std::distance(aimbotLockPartsR6.begin(), it)) }; lockPart = plr.findFirstChild(aimbotLockPartsR15[index]); } RBX::Vector3 lockPartPos{ lockPart.getPosition() }; RBX::Vector2 screenPos{ visualEngine.worldToScreen(lockPartPos) }; float dx{ screenPos.x - mousePos.x }; float dy{ screenPos.y - mousePos.y }; float dist{ sqrtf(dx * dx + dy * dy) }; if (dist < Settings::silentAimFOVRadius && dist < closestDistance) { closestDistance = dist; bestPlr = plr; bestPos = screenPos; } } silent_closestPlr = bestPlr; silent_targetPos = bestPos; if (silent_closestPlr.address == nullptr) { silent_targetPos.x = static_cast<float>(mousePos.x); silent_targetPos.y = static_cast<float>(mousePos.y); } Sleep(1); } }).detach(); std::thread([&]() { while (true) { if (!Settings::silentAimEnabled) { Sleep(100); continue; } RBX::Instance mouseService{ dataModel.findFirstChildOfClass("MouseService") }; RBX::Instance inputObject{ RBX::Memory::read<void*>((void*)((uintptr_t)mouseService.address + Offsets::InputObject)) }; RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); RBX::Memory::write<RBX::Vector2>((void*)((uintptr_t)inputObject.address + Offsets::MousePosition), silent_targetPos); } }).detach();
